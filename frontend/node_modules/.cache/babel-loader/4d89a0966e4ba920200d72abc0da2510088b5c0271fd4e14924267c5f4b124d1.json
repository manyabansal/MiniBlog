{"ast":null,"code":"//\n// FileReader\n//\n// http://www.w3.org/TR/FileAPI/#dfn-filereader\n// https://developer.mozilla.org/en/DOM/FileReader\n(function () {\n  \"use strict\";\n\n  var fs = require(\"fs\"),\n    EventEmitter = require(\"events\").EventEmitter;\n  function doop(fn, args, context) {\n    if ('function' === typeof fn) {\n      fn.apply(context, args);\n    }\n  }\n  function toDataUrl(data, type) {\n    // var data = self.result;\n    var dataUrl = 'data:';\n    if (type) {\n      dataUrl += type + ';';\n    }\n    if (/text/i.test(type)) {\n      dataUrl += 'charset=utf-8,';\n      dataUrl += data.toString('utf8');\n    } else {\n      dataUrl += 'base64,';\n      dataUrl += data.toString('base64');\n    }\n    return dataUrl;\n  }\n  function mapDataToFormat(file, data, format, encoding) {\n    // var data = self.result;\n\n    switch (format) {\n      case 'buffer':\n        return data;\n        break;\n      case 'binary':\n        return data.toString('binary');\n        break;\n      case 'dataUrl':\n        return toDataUrl(data, file.type);\n        break;\n      case 'text':\n        return data.toString(encoding || 'utf8');\n        break;\n    }\n  }\n  function FileReader() {\n    var self = this,\n      emitter = new EventEmitter(),\n      file;\n    self.addEventListener = function (on, callback) {\n      emitter.on(on, callback);\n    };\n    self.removeEventListener = function (callback) {\n      emitter.removeListener(callback);\n    };\n    self.dispatchEvent = function (on) {\n      emitter.emit(on);\n    };\n    self.EMPTY = 0;\n    self.LOADING = 1;\n    self.DONE = 2;\n    self.error = undefined; // Read only\n    self.readyState = self.EMPTY; // Read only\n    self.result = undefined; // Road only\n\n    // non-standard\n    self.on = function () {\n      emitter.on.apply(emitter, arguments);\n    };\n    self.nodeChunkedEncoding = false;\n    self.setNodeChunkedEncoding = function (val) {\n      self.nodeChunkedEncoding = val;\n    };\n    // end non-standard\n\n    // Whatever the file object is, turn it into a Node.JS File.Stream\n    function createFileStream() {\n      var stream = new EventEmitter(),\n        chunked = self.nodeChunkedEncoding;\n\n      // attempt to make the length computable\n      if (!file.size && chunked && file.path) {\n        fs.stat(file.path, function (err, stat) {\n          file.size = stat.size;\n          file.lastModifiedDate = stat.mtime;\n        });\n      }\n\n      // The stream exists, do nothing more\n      if (file.stream) {\n        return;\n      }\n\n      // Create a read stream from a buffer\n      if (file.buffer) {\n        process.nextTick(function () {\n          stream.emit('data', file.buffer);\n          stream.emit('end');\n        });\n        file.stream = stream;\n        return;\n      }\n\n      // Create a read stream from a file\n      if (file.path) {\n        // TODO url\n        if (!chunked) {\n          fs.readFile(file.path, function (err, data) {\n            if (err) {\n              stream.emit('error', err);\n            }\n            if (data) {\n              stream.emit('data', data);\n              stream.emit('end');\n            }\n          });\n          file.stream = stream;\n          return;\n        }\n\n        // TODO don't duplicate this code here,\n        // expose a method in File instead\n        file.stream = fs.createReadStream(file.path);\n      }\n    }\n\n    // before any other listeners are added\n    emitter.on('abort', function () {\n      self.readyState = self.DONE;\n    });\n\n    // Map `error`, `progress`, `load`, and `loadend`\n    function mapStreamToEmitter(format, encoding) {\n      var stream = file.stream,\n        buffers = [],\n        chunked = self.nodeChunkedEncoding;\n      buffers.dataLength = 0;\n      stream.on('error', function (err) {\n        if (self.DONE === self.readyState) {\n          return;\n        }\n        self.readyState = self.DONE;\n        self.error = err;\n        emitter.emit('error', err);\n      });\n      stream.on('data', function (data) {\n        if (self.DONE === self.readyState) {\n          return;\n        }\n        buffers.dataLength += data.length;\n        buffers.push(data);\n        emitter.emit('progress', {\n          // fs.stat will probably complete before this\n          // but possibly it will not, hence the check\n          lengthComputable: !isNaN(file.size) ? true : false,\n          loaded: buffers.dataLength,\n          total: file.size\n        });\n        emitter.emit('data', data);\n      });\n      stream.on('end', function () {\n        if (self.DONE === self.readyState) {\n          return;\n        }\n        var data;\n        if (buffers.length > 1) {\n          data = Buffer.concat(buffers);\n        } else {\n          data = buffers[0];\n        }\n        self.readyState = self.DONE;\n        self.result = mapDataToFormat(file, data, format, encoding);\n        emitter.emit('load', {\n          target: {\n            // non-standard\n            nodeBufferResult: data,\n            result: self.result\n          }\n        });\n        emitter.emit('loadend');\n      });\n    }\n\n    // Abort is overwritten by readAsXyz\n    self.abort = function () {\n      if (self.readState == self.DONE) {\n        return;\n      }\n      self.readyState = self.DONE;\n      emitter.emit('abort');\n    };\n\n    // \n    function mapUserEvents() {\n      emitter.on('start', function () {\n        doop(self.onloadstart, arguments);\n      });\n      emitter.on('progress', function () {\n        doop(self.onprogress, arguments);\n      });\n      emitter.on('error', function (err) {\n        // TODO translate to FileError\n        if (self.onerror) {\n          self.onerror(err);\n        } else {\n          if (!emitter.listeners.error || !emitter.listeners.error.length) {\n            throw err;\n          }\n        }\n      });\n      emitter.on('load', function () {\n        doop(self.onload, arguments);\n      });\n      emitter.on('end', function () {\n        doop(self.onloadend, arguments);\n      });\n      emitter.on('abort', function () {\n        doop(self.onabort, arguments);\n      });\n    }\n    function readFile(_file, format, encoding) {\n      file = _file;\n      if (!file || !file.name || !(file.path || file.stream || file.buffer)) {\n        throw new Error(\"cannot read as File: \" + JSON.stringify(file));\n      }\n      if (0 !== self.readyState) {\n        console.log(\"already loading, request to change format ignored\");\n        return;\n      }\n\n      // 'process.nextTick' does not ensure order, (i.e. an fs.stat queued later may return faster)\n      // but `onloadstart` must come before the first `data` event and must be asynchronous.\n      // Hence we waste a single tick waiting\n      process.nextTick(function () {\n        self.readyState = self.LOADING;\n        emitter.emit('loadstart');\n        createFileStream();\n        mapStreamToEmitter(format, encoding);\n        mapUserEvents();\n      });\n    }\n    self.readAsArrayBuffer = function (file) {\n      readFile(file, 'buffer');\n    };\n    self.readAsBinaryString = function (file) {\n      readFile(file, 'binary');\n    };\n    self.readAsDataURL = function (file) {\n      readFile(file, 'dataUrl');\n    };\n    self.readAsText = function (file, encoding) {\n      readFile(file, 'text', encoding);\n    };\n  }\n  module.exports = FileReader;\n})();","map":{"version":3,"names":["fs","require","EventEmitter","doop","fn","args","context","apply","toDataUrl","data","type","dataUrl","test","toString","mapDataToFormat","file","format","encoding","FileReader","self","emitter","addEventListener","on","callback","removeEventListener","removeListener","dispatchEvent","emit","EMPTY","LOADING","DONE","error","undefined","readyState","result","arguments","nodeChunkedEncoding","setNodeChunkedEncoding","val","createFileStream","stream","chunked","size","path","stat","err","lastModifiedDate","mtime","buffer","process","nextTick","readFile","createReadStream","mapStreamToEmitter","buffers","dataLength","length","push","lengthComputable","isNaN","loaded","total","Buffer","concat","target","nodeBufferResult","abort","readState","mapUserEvents","onloadstart","onprogress","onerror","listeners","onload","onloadend","onabort","_file","name","Error","JSON","stringify","console","log","readAsArrayBuffer","readAsBinaryString","readAsDataURL","readAsText","module","exports"],"sources":["C:/Users/maany/OneDrive/Desktop/myBlog/my-blog/node_modules/filereader/FileReader.js"],"sourcesContent":["//\n// FileReader\n//\n// http://www.w3.org/TR/FileAPI/#dfn-filereader\n// https://developer.mozilla.org/en/DOM/FileReader\n(function () {\n  \"use strict\";\n\n  var fs = require(\"fs\")\n    , EventEmitter = require(\"events\").EventEmitter\n    ;\n\n  function doop(fn, args, context) {\n    if ('function' === typeof fn) {\n      fn.apply(context, args);\n    }\n  }\n\n  function toDataUrl(data, type) {\n    // var data = self.result;\n    var dataUrl = 'data:';\n\n    if (type) {\n      dataUrl += type + ';';\n    }\n\n    if (/text/i.test(type)) {\n      dataUrl += 'charset=utf-8,';\n      dataUrl += data.toString('utf8');\n    } else {\n      dataUrl += 'base64,';\n      dataUrl += data.toString('base64');\n    }\n\n    return dataUrl;\n  }\n\n  function mapDataToFormat(file, data, format, encoding) {\n    // var data = self.result;\n\n    switch(format) {\n      case 'buffer':\n        return data;\n        break;\n      case 'binary':\n        return data.toString('binary');\n        break;\n      case 'dataUrl':\n        return toDataUrl(data, file.type);\n        break;\n      case 'text':\n        return data.toString(encoding || 'utf8');\n        break;\n    }\n  }\n\n  function FileReader() {\n    var self = this,\n      emitter = new EventEmitter,\n      file;\n\n    self.addEventListener = function (on, callback) {\n      emitter.on(on, callback);\n    };\n    self.removeEventListener = function (callback) {\n      emitter.removeListener(callback);\n    }\n    self.dispatchEvent = function (on) {\n      emitter.emit(on);\n    }\n\n    self.EMPTY = 0;\n    self.LOADING = 1;\n    self.DONE = 2;\n\n    self.error = undefined;         // Read only\n    self.readyState = self.EMPTY;   // Read only\n    self.result = undefined;        // Road only\n\n    // non-standard\n    self.on = function () {\n      emitter.on.apply(emitter, arguments);\n    }\n    self.nodeChunkedEncoding = false;\n    self.setNodeChunkedEncoding = function (val) {\n      self.nodeChunkedEncoding = val;\n    };\n    // end non-standard\n\n\n\n    // Whatever the file object is, turn it into a Node.JS File.Stream\n    function createFileStream() {\n      var stream = new EventEmitter(),\n        chunked = self.nodeChunkedEncoding;\n\n      // attempt to make the length computable\n      if (!file.size && chunked && file.path) {\n        fs.stat(file.path, function (err, stat) {\n          file.size = stat.size;\n          file.lastModifiedDate = stat.mtime;\n        });\n      }\n\n\n      // The stream exists, do nothing more\n      if (file.stream) {\n        return;\n      }\n\n\n      // Create a read stream from a buffer\n      if (file.buffer) {\n        process.nextTick(function () {\n          stream.emit('data', file.buffer);\n          stream.emit('end');\n        });\n        file.stream = stream;\n        return;\n      }\n\n\n      // Create a read stream from a file\n      if (file.path) {\n        // TODO url\n        if (!chunked) {\n          fs.readFile(file.path, function (err, data) {\n            if (err) {\n              stream.emit('error', err);\n            }\n            if (data) {\n              stream.emit('data', data);\n              stream.emit('end');\n            }\n          });\n\n          file.stream = stream;\n          return;\n        }\n\n        // TODO don't duplicate this code here,\n        // expose a method in File instead\n        file.stream = fs.createReadStream(file.path);\n      }\n    }\n\n\n\n    // before any other listeners are added\n    emitter.on('abort', function () {\n      self.readyState = self.DONE;\n    });\n\n\n\n    // Map `error`, `progress`, `load`, and `loadend`\n    function mapStreamToEmitter(format, encoding) {\n      var stream = file.stream,\n        buffers = [],\n        chunked = self.nodeChunkedEncoding;\n\n      buffers.dataLength = 0;\n\n      stream.on('error', function (err) {\n        if (self.DONE === self.readyState) {\n          return;\n        }\n\n        self.readyState = self.DONE;\n        self.error = err;\n        emitter.emit('error', err);\n      });\n\n      stream.on('data', function (data) {\n        if (self.DONE === self.readyState) {\n          return;\n        }\n\n        buffers.dataLength += data.length;\n        buffers.push(data);\n\n        emitter.emit('progress', {\n          // fs.stat will probably complete before this\n          // but possibly it will not, hence the check\n          lengthComputable: (!isNaN(file.size)) ? true : false,\n          loaded: buffers.dataLength,\n          total: file.size\n        });\n\n        emitter.emit('data', data);\n      });\n\n      stream.on('end', function () {\n        if (self.DONE === self.readyState) {\n          return;\n        }\n\n        var data;\n\n        if (buffers.length > 1 ) {\n          data = Buffer.concat(buffers);\n        } else {\n          data = buffers[0];\n        }\n\n        self.readyState = self.DONE;\n        self.result = mapDataToFormat(file, data, format, encoding);\n        emitter.emit('load', {\n          target: {\n            // non-standard\n            nodeBufferResult: data,\n            result: self.result\n          }\n        });\n\n        emitter.emit('loadend');\n      });\n    }\n\n\n    // Abort is overwritten by readAsXyz\n    self.abort = function () {\n      if (self.readState == self.DONE) {\n        return;\n      }\n      self.readyState = self.DONE;\n      emitter.emit('abort');\n    };\n\n\n\n    // \n    function mapUserEvents() {\n      emitter.on('start', function () {\n        doop(self.onloadstart, arguments);\n      });\n      emitter.on('progress', function () {\n        doop(self.onprogress, arguments);\n      });\n      emitter.on('error', function (err) {\n        // TODO translate to FileError\n        if (self.onerror) {\n          self.onerror(err);\n        } else {\n          if (!emitter.listeners.error || !emitter.listeners.error.length) {\n            throw err;\n          }\n        }\n      });\n      emitter.on('load', function () {\n        doop(self.onload, arguments);\n      });\n      emitter.on('end', function () {\n        doop(self.onloadend, arguments);\n      });\n      emitter.on('abort', function () {\n        doop(self.onabort, arguments);\n      });\n    }\n\n\n\n    function readFile(_file, format, encoding) {\n      file = _file;\n      if (!file || !file.name || !(file.path || file.stream || file.buffer)) {\n        throw new Error(\"cannot read as File: \" + JSON.stringify(file));\n      }\n      if (0 !== self.readyState) {\n        console.log(\"already loading, request to change format ignored\");\n        return;\n      }\n\n      // 'process.nextTick' does not ensure order, (i.e. an fs.stat queued later may return faster)\n      // but `onloadstart` must come before the first `data` event and must be asynchronous.\n      // Hence we waste a single tick waiting\n      process.nextTick(function () {\n        self.readyState = self.LOADING;\n        emitter.emit('loadstart');\n        createFileStream();\n        mapStreamToEmitter(format, encoding);\n        mapUserEvents();\n      });\n    }\n\n    self.readAsArrayBuffer = function (file) {\n      readFile(file, 'buffer');\n    };\n    self.readAsBinaryString = function (file) {\n      readFile(file, 'binary');\n    };\n    self.readAsDataURL = function (file) {\n      readFile(file, 'dataUrl');\n    };\n    self.readAsText = function (file, encoding) {\n      readFile(file, 'text', encoding);\n    };\n  }\n\n  module.exports = FileReader;\n}());\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}